package amyc
package codegen

import analyzer._
import ast.{Identifier, SymbolicTreeModule}
import ast.SymbolicTreeModule.{
  And => AmyAnd,
  Call => AmyCall,
  Div => AmyDiv,
  Or => AmyOr,
  _
}
import utils.{Context, Pipeline}
import wasm._
import Instructions._
import Utils._

// Generates WebAssembly code for an Amy program
object CodeGen extends Pipeline[(Program, SymbolTable), Module] {
  def run(ctx: Context)(v: (Program, SymbolTable)): Module = {
    val (program, table) = v

    // Generate code for an Amy module
    def cgModule(moduleDef: ModuleDef): List[Function] = {
      val ModuleDef(name, defs, optExpr) = moduleDef
      // Generate code for all functions
      defs.collect {
        case fd: FunDef if !builtInFunctions(fullName(name, fd.name)) =>
          cgFunction(fd, name, false)
      } ++
        // Generate code for the "main" function, which contains the module expression
        optExpr.toList.map { expr =>
          val mainFd =
            FunDef(Identifier.fresh("main"), Nil, TypeTree(IntType), expr)
          cgFunction(mainFd, name, true)
        }
    }

    // Generate code for a function in module 'owner'
    def cgFunction(fd: FunDef, owner: Identifier, isMain: Boolean): Function = {
      // Note: We create the wasm function name from a combination of
      // module and function name, since we put everything in the same wasm module.
      val name = fullName(owner, fd.name)
      Function(name, fd.params.size, isMain) { lh =>
        val locals = fd.paramNames.zipWithIndex.toMap
        val body = cgExpr(fd.body)(locals, lh)
        if (isMain) {
          body <:> Drop // Main functions do not return a value,
          // so we need to drop the value generated by their body
        } else {
          body
        }
      }
    }

    // Generate code for an expression expr.
    // Additional arguments are a mapping from identifiers (parameters and variables) to
    // their index in the wasm local variables, and a LocalsHandler which will generate
    // fresh local slots as required.
    def cgExpr(
        expr: Expr
    )(implicit locals: Map[Identifier, Int], lh: LocalsHandler): Code = {
      def matchAndBind(p: Pattern): (Code, Map[Identifier, Int]) = {
        //assume v is on the stack, matchAndBind consumes it and push the boolean
        p match {
          case WildcardPattern() => (Drop <:> Const(1), Map.empty) //return true
          case IdPattern(id) =>
            val newLocal = lh.getFreshLocal()
            //store v in the Local id
            val code = SetLocal(newLocal) <:>
              //return true
              Const(1)

            (code, Map.empty + ((id, newLocal)))
          case LiteralPattern(lit) =>
            val code = cgExpr(lit) <:>
              Eq
            (code, Map.empty)
          case CaseClassPattern(constr, args) =>
            val constrSig = table.getConstructor(constr).get
            val vPtr = lh.getFreshLocal()
            val argsWithIndex = args.zip(1 to args.size)
            val mbargs = argsWithIndex.map(elem => {
              val matchAndBindRes = matchAndBind(elem._1)
              val code = GetLocal(vPtr) <:> Const(4 * elem._2) <:> Add <:> Load <:>
                //Now the pattern is loaded on the stack
                matchAndBindRes._1 <:>
                And
              (code, matchAndBindRes._2)

            })
            val mbargsCode = mbargs.map(_._1)
            val mbargsMap =
              mbargs.map(_._2).foldLeft(Map.empty[Identifier, Int])(_ ++ _)

            //store v because will be needed
            val code =
              SetLocal(vPtr) <:>
                GetLocal(vPtr) <:>
                Load <:>
                //Constructor's index is on the stack
                Const(constrSig.index) <:>
                Eq <:>
                If_i32 <:>
                //matchAndBind every arguments
                //load a true (base case like for foldLeft)
                Const(1) <:>
                mbargsCode <:>
                Else <:>
                //Constructor doesn't match so return false
                Const(0) <:>
                End
            (code, mbargsMap)
          case _ =>
            (Unreachable, Map.empty)
        }
      }

      expr match {
        //Literals
        case Variable(name) =>
          GetLocal(locals.get(name).get)
        case IntLiteral(value) =>
          Const(value)
        case BooleanLiteral(value) =>
          if (value) Const(1) else Const(0)
        case StringLiteral(value) =>
          Utils.mkString(value)
        case UnitLiteral() =>
          Const(0)

        //Binary operations
        case Plus(lhs, rhs) =>
          cgExpr(lhs) <:>
            cgExpr(rhs) <:>
            Add
        case Minus(lhs, rhs) =>
          cgExpr(lhs) <:>
            cgExpr(rhs) <:>
            Sub
        case Times(lhs, rhs) =>
          cgExpr(lhs) <:>
            cgExpr(rhs) <:>
            Mul
        case AmyDiv(lhs, rhs) =>
          cgExpr(lhs) <:>
            cgExpr(rhs) <:>
            Div
        case Mod(lhs, rhs) =>
          cgExpr(lhs) <:>
            cgExpr(rhs) <:>
            Rem
        case LessThan(lhs, rhs) =>
          cgExpr(lhs) <:>
            cgExpr(rhs) <:>
            Lt_s
        case LessEquals(lhs, rhs) =>
          cgExpr(lhs) <:>
            cgExpr(rhs) <:>
            Le_s
        case AmyAnd(lhs, rhs) =>
          cgExpr(lhs) <:>
            If_i32 <:>
            cgExpr(rhs) <:>
            Else <:>
            Const(0) <:>
            End
        case AmyOr(lhs, rhs) =>
          cgExpr(lhs) <:>
            If_i32 <:>
            Const(1) <:>
            Else <:>
            cgExpr(rhs) <:>
            End
        case Equals(lhs, rhs) =>
          cgExpr(lhs) <:>
            cgExpr(rhs) <:>
            Eq
        case Concat(lhs, rhs) =>
          cgExpr(lhs) <:>
            cgExpr(rhs) <:>
            Call(concatImpl.name)

        //unary operator
        case Not(expr) =>
          cgExpr(expr) <:>
            Eqz
        case Neg(expr) =>
          Const(0) <:>
            cgExpr(expr) <:>
            Sub

        case Ite(cond, thenn, elze) =>
          cgExpr(cond) <:>
            If_i32 <:>
            cgExpr(thenn) <:>
            Else <:>
            cgExpr(elze) <:>
            End

        case Let(df, value, body) =>
          val id = lh.getFreshLocal()
          cgExpr(value) <:>
            SetLocal(id) <:>
            cgExpr(body)(locals + ((df.name, id)), lh)

        case Sequence(expr1, expr2) =>
          cgExpr(expr1) <:>
            Drop <:>
            cgExpr(expr2)

        case Error(msg) =>
          cgExpr(msg) <:>
            Call("Std_printString") <:>
            Unreachable

        case AmyCall(qname, args) =>
          val optFun = table.getFunction(qname)
          if (optFun.isDefined) {
            val name = fullName(optFun.get.owner, qname);
            //Load args on the stack
            args.map(cgExpr(_)) <:>
              //call the function
              Call(name)
          } else {
            val constrSig = table.getConstructor(qname).get
            //we know it 's defined due to type- and name analysis
            val index = constrSig.index
            val localPointer = lh.getFreshLocal()
            val adtSize = 4 * (1 + constrSig.argTypes.size)
            val incrementLocalPointer = Const(4) <:> GetLocal(localPointer) <:> Add <:> SetLocal(
              localPointer
            )
            val storeArgs = for (arg <- args) yield {
              GetLocal(localPointer) <:> cgExpr(arg) <:> Store <:> incrementLocalPointer
            }

            //return the old memoryBoundary (where index is stored) to the caller by putting it on the stack
            GetGlobal(memoryBoundary) <:>
              GetGlobal(memoryBoundary) <:> SetLocal(localPointer) <:>
              GetGlobal(memoryBoundary) <:> Const(adtSize) <:> Add <:> SetGlobal(
              memoryBoundary
            ) <:>
              //store constructor's index
              GetLocal(localPointer) <:> Const(index) <:> Store <:>
              incrementLocalPointer <:>
              storeArgs
          }

        case Match(scrut, cases) =>
          val scrutLocalPtr = lh.getFreshLocal()
          val matchLabel = getFreshLabel("match")
          val returnExpr = lh.getFreshLocal()

          def handleOneCase(lCases: List[MatchCase]): Code = {
            lCases match {
              case cse :: tail =>
                val mabRes = matchAndBind(cse.pat)
                GetLocal(scrutLocalPtr) <:>
                  mabRes._1 <:>
                  If_void <:>
                  cgExpr(cse.expr)(locals ++ mabRes._2, lh) <:>
                  SetLocal(returnExpr) <:>
                  Br(matchLabel) <:>
                  Else <:>
                  handleOneCase(tail) <:>
                  End
              case Nil =>
                mkString(s"Match error $matchLabel") <:> Call("Std_printString") <:> Unreachable
            }
          }

          Block(matchLabel) <:>
            cgExpr(scrut) <:> SetLocal(scrutLocalPtr) <:>
            handleOneCase(cases) <:>
            End <:>
            GetLocal(returnExpr)

        case _ =>
          Unreachable
      }
    }

    Module(
      program.modules.last.name.name,
      defaultImports,
      globalsNo,
      wasmFunctions ++ (program.modules flatMap cgModule)
    )

  }
}
